package rekkura.state.algorithm;

import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.Set;

import com.google.common.collect.HashMultimap;
import com.google.common.collect.Maps;
import com.google.common.collect.Multimap;
import com.google.common.collect.Sets;

/**
 * Use this class when you need to generated data (D) from nodes (N)
 * in a graph in such a way that an edge of the graph from A to
 * B represents a dependence between the data generated by A and the
 * data generated B. Recursion is supported.
 * 
 * @author ptpham
 *
 * @param <N>
 * @param <D>
 */
public class BackwardTraversal<N, D> {
	public interface Visitor<N, D> { Set<D> expandNode(N node); }
	
	/**
	 * This should be the directed graph that gives for each node,
	 * the nodes it depends on.
	 */
	public final Multimap<N, N> graph;
	
	/**
	 * The prover will not expand any node that has non-zero entries here.
	 */
	public final HashMultimap<N, D> known = HashMultimap.create();
	
	public final HashMultimap<N, D> pending = HashMultimap.create();
	
	/**
	 * This multiset gives the index of the strongly connected component
	 * the node belongs to.
	 */
	public final Map<N, Integer> indices = Maps.newHashMap();
	
	/**
	 * This maintains the strongly connected component sets. This
	 * set does not include nodes that are not in a strongly connected
	 * component.
	 */
	public final List<Set<N>> components;
	
	/**
	 * This array is used to coordinate across a strongly connected
	 * component. The first node reached in the component becomes the 
	 * root of the component and continues to ask into the component
	 * as long as new data are being generated.
	 */
	private final boolean[] rooted;
	private final Set<N> asking = Sets.newHashSet();
	
	private final Visitor<N,D> visitor;
	
	public BackwardTraversal(Visitor<N,D> visitor, Multimap<N,N> graph) {
		this.graph = graph;
		this.visitor = visitor;
		this.components = Topper.stronglyConnected(graph);
		for (int i = 0; i < components.size(); i++) {
			Set<N> cycle = components.get(i);
			for (N node : cycle) indices.put(node, i);
		}
		
		rooted = new boolean[components.size()];
	}

	public void clear() {
		this.pending.clear();
		this.asking.clear();
		this.known.clear();
		
		Arrays.fill(rooted, false);
	}

	public boolean ask(N node, Set<D> result) {
		if (known.containsKey(node)) {
			result.addAll(known.get(node));
			return false;
		}
		
		boolean inComponent = this.indices.containsKey(node);
		if (inComponent) {
			int index = this.indices.get(node);
			return expandComponentNode(node, result, index);
		} else return expandNodeToMap(node, result, this.known);
	}

	private boolean expandComponentNode(N node, Set<D> result, int index) {
		boolean root = !this.rooted[index];
		if (!this.asking.add(node)) return false;
		
		boolean expanded = false;
		if (root) expanded = expandNodeAsRoot(node, result, index);
		else expanded = expandNodeToMap(node, result, this.pending);
		
		this.asking.remove(node);
		return expanded;
	}

	/**
	 * The root (the first node reached in this strongly connected
	 * component) acts as the base for a loop that continues
	 * as long as new data are being generated. Once everything 
	 * has been generated, the data in pending are move to known
	 * for the entire component.
	 * @param node
	 * @param result
	 * @param index
	 * @return
	 */
	private boolean expandNodeAsRoot(N node, Set<D> result, int index) {
		boolean expanded = false;

		this.rooted[index] = true;
		while (true) {
			boolean current = expandNodeToMap(node, result, this.pending);
			expanded |= current;
			if (!current) break;
		}
		this.rooted[index] = false;
		
		for (N member : this.components.get(index)) {
			this.known.putAll(member, this.pending.get(member));
			this.pending.removeAll(member);
		}
		
		return expanded;
	}

	private boolean expandNodeToMap(N node, Set<D> result, Multimap<N, D> map) {
		boolean expanded = false;
		for (N parent : this.graph.get(node)) expanded |= ask(parent, result);
		
		Set<D> generated = this.visitor.expandNode(node);
		map.putAll(node, generated);
		expanded |= result.addAll(generated);
		return expanded;
	}
}
