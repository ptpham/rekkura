package rekkura.state.algorithm;

import java.util.List;
import java.util.Map;
import java.util.Set;

import rekkura.util.Colut;
import rekkura.util.OtmUtil;

import com.google.common.collect.*;

/**
 * Use this class when you need to generated data (D) from nodes (N)
 * in a graph in such a way that an edge of the graph from A to
 * B represents a dependence between the data generated by A and the
 * data generated B. Recursion is supported.
 * 
 * @author ptpham
 *
 * @param <N>
 * @param <D>
 */
public class BackwardTraversal<N, D> {
	public interface Visitor<N, D> { Set<D> expandNode(N node); }
	
	/**
	 * This should be the directed graph that gives for each node,
	 * the nodes it depends on.
	 */
	public final Multimap<N, N> backward;
	public final Multimap<N, N> forward;
	
	/**
	 * The prover will not expand any node that has non-zero entries here.
	 */
	public final HashMultimap<N, D> known = HashMultimap.create();
	public final Map<N, Set<N>> components = Maps.newHashMap();
	private final Visitor<N,D> visitor;
	
	public BackwardTraversal(Visitor<N,D> visitor, Multimap<N,N> graph) {
		this.backward = graph;
		this.visitor = visitor;
		
		this.forward = HashMultimap.create();
		Multimaps.invertFrom(graph, forward);
		List<Set<N>> components = Topper.stronglyConnected(graph);
		for (int i = 0; i < components.size(); i++) {
			Set<N> cycle = components.get(i);
			for (N node : cycle) this.components.put(node, cycle);
		}
	}

	public void clear() { this.known.clear(); }
	public boolean ask(N node, Set<D> result) {
		if (known.containsKey(node)) {
			result.addAll(known.get(node));
			return false;
		}
		
		Set<N> component = this.components.get(node);
		if (component != null) return expandComponent(component, result);
		else return expandNodeRecursive(node, result);
	}

	private boolean expandComponent(Set<N> component, Set<D> result) {
		boolean expanded = false;
		
		// First ask beyond the of the component
		Set<N> beyond = Sets.newHashSet(OtmUtil.getAll(backward, component).values());
		beyond.removeAll(component);
		for (N node : beyond) expanded |= ask(node, result);
		
		// Now loop inside of the component until nothing new is generated
		Set<N> explore = Sets.newHashSet(component);
		while (explore.size() > 0) {
			N node = Colut.popAny(explore);
			boolean current = expandNode(node, result);
			if (current) pushForward(component, explore, node);
			expanded |= current;
		}
		
		return expanded;
	}

	private void pushForward(Set<N> component, Set<N> explore, N node) {
		for (N child : forward.get(node)) {
			if (!component.contains(child)) continue;
			explore.add(child);
		}
	}

	private boolean expandNodeRecursive(N node, Set<D> result) {
		boolean expanded = false;
		for (N parent : this.backward.get(node)) expanded |= ask(parent, result);
		expanded |= expandNode(node, result);
		return expanded;
	}

	private boolean expandNode(N node, Set<D> result) {
		boolean expanded = false;
		Set<D> generated = this.visitor.expandNode(node);
		this.known.putAll(node, generated);
		expanded |= result.addAll(generated);
		return expanded;
	}
}
